package chomsky;

import java.util.HashSet;
import java.util.Set;

import chomsky.cellule.CellArray;
import chomsky.components.Alphabet;
import chomsky.components.NonTerminal;
import chomsky.components.Symbol;
import chomsky.production.Productions;

/**
 * Class that represents a chomsky grammar
 */

public class ChomskyGrammar {

	Alphabet alphabet;
	Productions productions;
	Set<NonTerminal> nonTerminaux;
	NonTerminal S;

	/**
	 * Create an empty chomsky grammar
	 */
	public ChomskyGrammar() {
		this.alphabet = new Alphabet();
		this.productions = new Productions();
		this.nonTerminaux = new HashSet<NonTerminal>();
		this.S = null;
	}

	/**
	 * Create a chomsky grammar
	 * 
	 * @param alphabet
	 *            the alphabet of the chomsky grammar
	 * @param productions
	 *            the productions of the chomsky grammar
	 * @param nonTerminaux
	 *            the non terminal symbols of the chomsky grammar
	 * @param S
	 *            the axiom of the chomsky grammar
	 */
	public ChomskyGrammar(Alphabet alphabet, Productions productions,
			Set<NonTerminal> nonTerminaux, NonTerminal S) {
		this.alphabet = alphabet;
		this.productions = productions;
		this.nonTerminaux = nonTerminaux;
		this.S = S;
	}

	/**
	 * Add a symbol to the alphabet of the chomsky grammar
	 * 
	 * @param s
	 *            the symbol to add
	 */
	public void addSymbolToAlphabet(Symbol s) {
		this.alphabet.add(s);
	}

	/**
	 * Add a non terminal symbol to the chomsky grammar
	 * 
	 * @param t
	 *            the non terminal symbol to add
	 */
	public void addNonTerminalSymbol(NonTerminal t) {
		this.nonTerminaux.add(t);
	}

	/**
	 * Set the axiom to S
	 * 
	 * @param S
	 *            the new axiom
	 */
	public void setAxiom(NonTerminal S) {
		if (!this.nonTerminaux.contains(S))
			this.nonTerminaux.add(S);
		this.S = S;
	}

	/**
	 * Add the t -> f production to the chomsky grammar
	 * 
	 * @param t
	 *            the left non terminal symbol
	 * @param f
	 *            the right terminal symbol
	 */
	public void addProduction(NonTerminal t, Symbol f) {
		this.productions.add(t, f);
	}

	/**
	 * add the t -> t1 t2 production to the chomsky grammar
	 * 
	 * @param t
	 *            the left non terminal symbol
	 * @param t1
	 *            the first right non terminal symbol
	 * @param t2
	 *            the second right non terminal symbol
	 */
	public void addProduction(NonTerminal t, NonTerminal t1, NonTerminal t2) {
		this.productions.add(t, t1, t2);
	}

	/**
	 * Convert the string into an array of symbols. Each char of the string
	 * representing a symbol.
	 * 
	 * @param word
	 *            the string to convert
	 * @return an array of symbols
	 */
	protected Symbol[] stringToSymbole(String word) {
		int stringLength = word.length();

		Symbol[] symboles = new Symbol[stringLength];

		char[] letters = new char[stringLength];
		word.getChars(0, stringLength, letters, 0);

		for (int i = 0; i < stringLength; i++)
			symboles[i] = this.alphabet.getSymbole(letters[i]);

		return symboles;
	}

	/**
	 * Return true if the word can be generated by the grammar, false otherwise.
	 * This method uses the CYK algorithm.
	 * @param word the word to test
	 * @return true if the word can be generated by the grammar, false otherwise
	 */
	public boolean accept(String word) {
		Symbol[] a = stringToSymbole(word);
		int n = word.length();
		CellArray cells = new CellArray(n, n);

		for (int i = 1; i <= n; i++)
			for (NonTerminal X : this.nonTerminaux)
				if (this.productions.contains(X, a[i - 1]))
					cells.add(1, i, X);

		for (int l = 2; l <= n; l++) {
			for (int i = 1; i <= n - l + 1; i++) {
				for (int m = 1; m <= l - 1; m++) {

					cells.addAll(l, i, this.productions.get(
							cells.getNonTerminaux(m, i),
							cells.getNonTerminaux(l - m, i + m)));

				}
			}
		}

		return cells.contains(n, 1, S);
	}

}
